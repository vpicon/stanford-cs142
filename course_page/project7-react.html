<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>CS142 Project 7: Sessions and Input</title>
    <meta name="description" content="Web Applications course at Stanford University">

    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/main.css">

    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>

    <script src="js/jquery.min.js"></script> 
    <script src="js/bootstrap.min.js"></script>

</head>


  <body>

    <header>

  <nav class="navbar">
    <div class="container">

      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">CS142 (Winter 2021)</a>
      </div>

      <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
        <ul class="nav navbar-nav navbar-right">
          
            
            
            <li class="">
              <a href="index.html">Home</a> 
            </li>
          
            
            
            <li class="">
              <a href="info.html">Class Info</a> 
            </li>
          
            
            
            <li class="">
              <a href="lectures.html">Lectures</a> 
            </li>
          
            
            
            <li class="nav-active">
              <a href="projects.html">Projects</a> 
            </li>
          
            
            
            <li class="">
              <a href="staff.html">Staff</a> 
            </li>
          
        </ul>
      </div>
      
    </div>
  </nav>
</header>


    

        <main><div class="container">

  <h1>CS142 Project 7: Sessions and Input</h1>

  <h4 class="text-muted">
    Due: Tuesday, March 9, 2021 at 11:59 PM
  </h4>

  <p>
  In this project, you will extend your work on Project #6 by adding the ability for users to
  login, comment on photos, and
  upload new photos. Note that these new feature additions are <strong>full stack</strong> in that
  you will need to modify both the front end (React app) and the back end (Node web server
  and MongoDB database).
  </p>

  <section>
    <h3 class="left-border">Setup</h3>
    <p>
    You should have MongoDB and Node.js installed on your system.
    If not, follow the <a href="install.html">installation instructions</a> now.
    </p>
    <p>
    Like in Project #6, you start by copying the files of your previous project's directory
    (<code>project6</code>) into a new directory named <code>project7</code> (<b>make sure
    that any hidden files are transferred as well, including the .babelrc and .eslintrc.json files</b>).
    Extract the contents of <a href="downloads/project7.zip">this zip file</a> into the <code>project7</code> directory.
    This zip file will add several new files. Do all of your work for this
    project in the <code>project7</code> directory.
    </p>
    <p>
    In order to do this assignment you need to fetch some new node modules and add them to your
    web server and React application.  To fetch the module use the command
    <code>npm install --save &lt;module&gt;</code> which will fetch the module name
    <code>&lt;module&gt;</code> into your <code>node_modules</code> directory and add the
    dependency to your <code>package.json</code> file. Use a <code>require</code> function to
    add the module to your web server.
    </p>
    You will need to fetch the following Express middleware modules into your node modules:
    <ul>
    <li><a href="https://github.com/expressjs/session"><code>express-session</code></a> -
    Express session is an
    Express middleware layer than handles session management for you. It was
    described in lecture.
    </li>

    <li><a href="https://github.com/expressjs/body-parser"><code>body-parser</code></a> -
    <code>body-parser</code> is an Express middleware layer for parsing the body of
    HTTP requests. You can use it to parse the JSON encoded POST request bodies we use in our
    server API. For example, if you pass a request with a body consisting of JSON object with
    a property <code>parameter_name</code>
    it will show up in the Express request handler as <code>request.body.parameter_name</code>.
    </li>

    <li><a href="https://www.npmjs.com/package/multer#readme"><code>multer</code></a> -
    <code>multer</code> is another Express middleware body parser that is capable of
    handling the multi part forms we need to upload photos.
    </li>
    </ul>
    <p>
    On most systems the following command should fetch the above modules:
    <div class="code">
<pre>npm  install --save express-session
npm  install --save body-parser
npm  install --save multer</pre>
    </div></p>
    <p>
    Add these to your <code>webServer.js</code> using require statements like:
    <div class="code"><pre>const session = require('express-session');
const bodyParser = require('body-parser');
const multer = require('multer');</pre></div>
    </p>
    <p>
    Finally you need to add the <code>express-session</code> and <code>body-parser</code>
    middleware to express with the Express <code>use</code> like so:
    <div class="code"><pre>app.use(session({secret: 'secretKey', resave: false, saveUninitialized: false}));
app.use(bodyParser.json());</pre></div>
    where <code>'secretKey'</code> is the secret you use to cryptographically protect the session
    cookie.
    We will use the <code>multer</code> middleware in the photo upload code.
    </p>
    <p>
    If you did Problem 2 of Project #6, you should be using <code>axios</code>
    to fetch models. See the <code>axios</code> <a href="https://github.com/axios/axios">documentation</a>
    for more details if you didn't implement it for project 6.
    </p>
    <p>
    Like in the previous assignment we provide a Mocha test of the server API so you can have
    confidence in your backend before you implement the front end code. <strong>In exchange for this nicety,
    you are limited to implementing the server API we specify. This means making sure that your code passes
    our provided tests before submitting. See the Testing section further below for details.</strong> If you
    extended your API while doing the Project #6 Extra Credit, you will need to patch the tests to handle your
    extended API. If you decide to do the extra credit for this project, you will need to pass additional
    provided tests as well.
    </p>
    <p>
    As in the previous project you will need to start your MongoDB instance.
    Start MongoDB by running command:
    <div class="code"><pre>mongod (the exact arguments depend on where you placed the database)</pre></div>
    and load the photo app data set by running the command:
    <div class="code"><pre>node loadDatabase.js</pre></div>
    Note that the version of this command we distribute with Project #7 loads the user object with a
    login_name (lowercase version of their last_name) and password of "weak". These properties
    will only appear when you run loadDatabase.js after you added the fields to the schema (in problem 1).
    </p>
  </section>

  <section>
    <h3 class="left-border">Start the Node.js web server</h3>
    <p>
    Once you have the database up and running you will need to start the web server. Although this
    can be done with the same command as the previous assignments (e.g. <code>node webServer.js</code>),
    it is more convenient to start the web server using a program that will automatically
    restart it when you change the <code>webServer.js</code>. Otherwise, you will spend
    time restarting the web server after each change you make or wondering why your change didn't work when
    you forget to restart it.
    </p>
    The command
    <div class="code"><pre>npm install -g nodemon</pre></div>
    will install a program named  <a href="http://nodemon.io">nodemon</a> that
    does this automatic restarting (you may need to run the command with <code>sudo</code>). Note that the <code>-g</code> flag installs the program globally so that you can run it anywhere. Start your web server with the command from your
    <code>project7</code> directory:
    <div class="code"><pre>nodemon webServer.js</pre></div>
    The command will run the web server and restart it every time the <code>webServer.js</code> file
    changes. If you have an error (e.g. JavaScript syntax error) that causes the Node to exit, nodemon
    will wait until you change the <code>webServer.js</code> file and then try to restart it.
    If you want to restart the web server without changing the file you can restart
    it manually by typing the two character command <code>rs</code> at the nodemon command. You will probably
    want to run this in its own window so you can see the logging messages from your Node.js code.
    </p>
    <p>
    After updating your Photo Share App with the new files from Project #7 and starting the database
    and web server make sure the app is still working before continuing on to the assignment.
    </p>
  </section>


  <section>
    <h3 class="left-border">Problem 1: Simple Login (15 points)</h3>
    <p>
    Extend your photo app to have the notion of an user being logged in.  If a user
    is logged in, the toolbar should include a small message "Hi &lt;firstname&gt;"  where &lt;firstname&gt;
    is the first name of the logged-in user.  The toolbar should also contain a button displaying "Logout"
    that will log the user out.
    </p>
    <p>
    If there is no user logged in, the toolbar should display "Please Login"
    and the main view of your application should
    display an new view component named <code>LoginRegister</code>. The
    <code>LoginRegister</code> view
    should provide a way for a user to login and, as part of Problem #4 below,
    register as a new user.
    All attempts to navigate to a different
    view (e.g. deep links) should result in the display being redirected to the <code>LoginRegister</code>
    view if no user is logged in. (See the hints section if you are unsure how to implement this.) In addition, the user list on the left should not be populated if the current user is not logged in. (See the section below about modifying the server endpoints to return a status of 401 (Unauthorized)).
    </p>
    <p>
    When a user logs in successfully the view should switch to displaying the user's details. If
    the user login fails (e.g. no user with the login_name) the view should report an
    appropriate error message and let the user try again.
    </p>
    <p>
    Extend your backend implementation to support the photo app's notion of logged in users.
    In making this change you will need to change both the database schema and the web server API.
    </p>
    <p>
    Extend the Mongoose schema for <code>User</code> to
    add a new property <code>login_name</code>.
    This property is a string containing
    the identifier the user will type when logging in (their "login name").
    </p>
    <p>Modify the web server API to support 2 new REST API calls for logging in and out a user.
    Like in the previous assignment we will use HTTP requests with JSON-encoded bodies to
    transmit model data. The API uses POST requests to:</p>
    <ul>
      <li><code>/admin/login</code> - Provides a way for the photo app's <code>LoginRegister</code>
      view to login in a user.
      The POST request JSON-encoded body should include a property <code>login_name</code>
      (no passwords for now) and reply with information needed by your app for logged in user.
      An HTTP status of 400 (Bad request) should be returned if the login failed (e.g. login_name is not a valid
      account). A parameter in the request body is accessed using <code>request.body.parameter_name</code>.
      Note the login register handler should ensure that there exists a user with the given
      <code>login_name</code>. If so, it stores some information in the Express
      session where it can be checked by other request handlers that need to know
      whether a user is logged in.</li>
      <li><code>/admin/logout</code>  - A POST request with an empty body to this URL will
        logout the user by clearing the
      information stored in the session. An HTTP status of 400 (Bad request) should be returned in the user is
      not currently logged in.</li>
    </ul>
    <p>
    As part of updating the web server to handle login/logout you need to update all requests (except
    to <code>/admin/login</code> and <code>/admin/logout</code>) to reject the request with a status
    of 401 (Unauthorized) if the session state does not report a user is logged in.
    </p>
  </section>

  <section>
    <h3 class="left-border">Problem 2: New Comments (15 points)</h3><p>
    Once you have implemented user login, the next step is to
    implement the ability to add comments to photos. In the
    photo detail view where you display the comments of a
    photo, add the ability for the
    currently logged in user to add a comment to the photo.
    You get to design the user interface (e.g. popup dialog, input field, etc.) for this feature.
    It should be obvious how to use it and what photo the comment is about. The display of the
    photo and its comments should be updated immediately to reflect the newly added comment.
    </p>
    <p>
    For the backend support extend the web server API with the following HTTP POST API:
    <ul>
      <li><code>/commentsOfPhoto/:photo_id</code> - Add a comment to the photo whose id
    is <code>photo_id</code>.  The body of the POST requests should be a JSON-encoded body with
    a single property  <code>comment</code> that contains the comment's text. The comment object created on
    the photo must include the identifier of the logged in user and the time when
    the comment was created.
    Your implementation should reject any empty comments with a status of 400 (Bad request).</li>
    </ul>
    </p>
  </section>

  <section>
    <h3 class="left-border">Problem 3: Photo Uploading (15 points)</h3>
    <p>
    Allow users to add new photos.  When a user is logged in, the main toolbar should
    have a button labelled "Add Photo" that allows the current logged in user to
    upload a photo to the app.  We will provide you with an example of how to upload files using
      HTML in the Hint section below.
    </p>
    <p>
      Extend the web server to support POST requests to the URL:
      <ul>
      <li><code>/photos/new</code> - Upload a photo for the current user.
        The body of the POST request should be the file (see hint below). The uploaded files
        should be placed in the <code>images</code> directory under an unique name
        you generated. The unique name, along with the creation data and logged in user id,
        should be placed in the new Photo object you create. A response status of 400 should
        be returned if there is no file in the POST request. See the Hint section for help with this.
      </li>
     </ul>
    </p>
  </section>

  <section>
    <h3 class="left-border">Problem 4: Registration and Passwords (15 points)</h3>
    <p>
    Enhance the LoginRegister view component to support new-user
    registration and passwords.  Extend the login portion to add a password field.
    Add a registration section that allows all the fields of the User object to be
    filled in.  To reduce the chance that the user typos that password the view should contain a
      an additional copy of the password field and
      the view should only allow the user
    to be created if the two password fields are identical. Good security practice requires that
      the passwords typed by the user shouldn't be visible in the view. Registration should be
    triggered by a button at the bottom of the page labelled "Register Me".  When the
    button is pushed either an error should be reported explaining *specifically* why it didn't work or
    a success message should be reported and the register form input fields should be cleared.
    </p>
    <p>
    For the backend extend the User object schema
    with a string field <code>password</code> that will store
    the password.  This is horribly insecure.  See the Extra Credit below if you
    can't bring yourself to implement something so insecure.
    </p>
    Extend the web server to support POST requests to the URL:
    <ul>
      <li><code>/user</code> to allow a user to register.  The registration POST takes a
        JSON-encoded body with the following properties:
        (<code>login_name, password, first_name, last_name, location, description, occupation</code>).  The
        post request handler must make sure that the new login_name is specified
        and doesn't already exist. The first_name, last_name, and password must be non-empty strings
        as well. If the information is valid,
        then a new user is created in the database. If there is an error, the response should
        return status 400 and a string indicating the error.</li>
    </ul>
     </p>
    <p>
     Enhance the <code>LoginRegister</code> view to support logging in with a password
     and check it as part of the post request to <code>/admin/login</code>.
    </p>
  </section>

  <section>
    <h3 class="left-border">Extra Credit #1: Salted Passwords (5 points)</h3>
    <p>
    Enhance the security of your password mechanism by implementing
     <i>salting</i>. The salting mechanism is described in
    the next few paragraphs.  The problem with the clear text password
    mechanism we implemented for Problem 4 is if someone is able to read
    the database (for example, a rogue
    system administrator) they can easily retrieve all of the passwords
    for all users.
    </p>
    <p>
    A better approach is to apply a message digest function such as
    SHA-1 to each password, and store only the message digest in the database.
    SHA-1 takes a string such as a password as input and produces a 40-character
    string of hex digits (called a <i>message digest</i>) as output. The
    output has two interesting properties: first, the digest provides a unique
    signature for the input string (there is no known way to produce two different
    strings with the same digest); second, given a message digest, there is no
    known way to produce a string that will generate that digest. When a user
    sets their password, you must invoke Node
    <a href="https://nodejs.org/api/crypto.html">crypto</a> package's
    <a href="https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm">
    <code>createHash</code></a> function to generate the SHA-1 digest corresponding
    to that password, and store only the digest in the database; once this is
    done you can discard the password. When a user enters
    a password to login, invoke createHash function to compute
    the digest, and compare that
    digest to what is stored in the database. With this approach, you can make
    sure that a user types the correct password when logging in, but if someone
    reads the digests from the database they cannot use that information to
    log in.
    </p>
    <p>
    However, the approach of the previous paragraph has one remaining flaw.
    Suppose an attacker gets a copy of the database containing the digests.
    Since the SHA-1 function is public, they can employ a fast <i>dictionary
    attack</i> to guess common passwords. To do this, the attacker takes each
    word from a dictionary and computes its digest using SHA-1. Then the
    attacker checks each digest in the database against the digests in the
    dictionary (this can be done very quickly by putting all of the dictionary
    digests in a hash table). If any user has chosen a simple dictionary word as
    their password, the attacker can guess it quickly.
    </p>
    <p>
    In order to make dictionary attacks more difficult, you must use password
    salting.  When a user sets their password, compute a random number and
    concatenate it with the password before computing the SHA-1 digest (the
    crypto package
    <a href="https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback">
    <code>randomBytes</code></a> function with a length of 8 will return a suitable random number. The
    random number is called a <i>salt</i>. Then store both the salt and the
    digest in the database. When checking passwords during login, retrieve the
    salt from the database, concatenate it to the password typed by the user,
    and compute the digest of this string for comparison with the digest in
    the database. With this approach an attacker who has gained access to the
    login database cannot use the simple dictionary attack described above;
    the digest of a dictionary word would need to include the salt for a particular
    account, which means that the attacker would need to recompute all of the
    dictionary digests for every distinct account in the database. This makes
    dictionary attacks more expensive.
    </p>
    <p>
    To implement this, remove the <code>password</code> property from the User schema and replace it
    with two new string properties: <code>password_digest</code>
    and <code>salt</code>. Update the user register and login to use this mechanism.
    </p>
    <p>
    You should create and write your implementation in a node module file named <code>cs142password.js</code>.
    This module should export two functions:
    <div class="code"><pre>
/*
 * Return a salted and hashed password entry from a
 * clear text password.
 * @param {string} clearTextPassword
 * @return {object} passwordEntry
 * where passwordEntry is an object with two string
 * properties:
 *      salt - The salt used for the password.
 *      hash - The sha1 hash of the password and salt
 */
function makePasswordEntry(clearTextPassword) {</pre>
    </div>
    and
    <div class="code">
<pre>/*
 * Return true if the specified clear text password
 * and salt generates the specified hash.
 * @param {string} hash
 * @param {string} salt
 * @param {string} clearTextPassword
 * @return {boolean}
 */
function doesPasswordMatch(hash, salt, clearTextPassword) {</pre>
    </div>
    We provide a Mocha test file <code>test/cs142passwordTest.js</code> that tests this interface. Please make sure
    that you pass the tests within this file before submitting. You will need to change the <code>package.json</code> scripts
    test line to <code>mocha serverApiTest.js sessionInputApiTest.js cs142passwordTest.js</code> so that running
    <code>npm test</code> runs these tests too. Changing this line also serves as indication that you've done this
    extra credit.

    You will also need to update the <code>loadDatabase.js</code> script to require <code>cs142password.js</code> and use
    it to generate the correct password properties in the new user objects that the script creates.
    </p>
  </section>

  <section>
    <h3 class="left-border">Extra Credit #2: Handle Browser Refresh (5 points)</h3>
    <p>
      For simplicity in the regular parts of this assignment we allow you to keep the application's
      session state in JavaScript memory. Although this makes
      implementation easier it means that a browser refresh causes the application to forget
      who is logged in.
    </p>
    <p>
      Extend your application to handle browser refresh like it did before you added the login
      session support. Your scheme should allow a user to do a browser refresh yet stay logged in.
      You are free to use whatever implemention techniques you want but they must:
      <ul>
      <li>Maintain backward compatibility with the other parts of this assignment, including the Mocha tests. </li>
      <li>Not mess up the security of the application.</li>
      <li>Work when submitted using the class assignment submission mechanism.</li>
     </ul>
    </p>
  </section>

  <section>
    <h3 class="left-border">Style Points (5 points)</h3>
    <p>
    These points will be awarded if your problem solutions have proper
    MVC decomposition, follow the software stack conventions, and ESLINT warning-free JavaScript.
    In addition, your code and templates must be clean and
    readable, and your Web pages must be at least "reasonably nice"
    in appearance and convenience.
    </p>
  </section>

  <section>
    <h3 class="left-border">Testing</h3>
    <p>
    For testing, we:
    <ul>
    <li>provide new test file named <code>test/sessionInputApiTest.js</code> that provides some
    test coverage of the new API calls.</li>
    <li>update the existing <code>test/serverApiTest.js</code> to login a user and provide the session information on each API call.</li>
    </ul>
    Our update overwrites the file <code>serverApiTest.js</code> so any changes you added in Project #6 as part of
    the extra credit will need to be backported. To help with the backporting (or if you're just
    curious), note that we we added a Cookie header key-value pair to the request options of each
    http request call. See the test file for details.
    </p>

    <p>
    <strong>Just like project #6, please make sure to pass the provided tests before submitting, as a
    portion of your grade will depend on how many of these tests you pass.</strong>
    </p>

    <p>
    Note the tests assume that the database has
      only the objects from  <code>loadDatabase.js</code>.  You should run <code>loadDatabase.js</code> before
      running the test.
    </p>
    <p>
      Before running any tests you should make sure your <code>test/node_modules</code> is up to
      date by typing the command:
      <code>npm install</code> in the <code>project7/test</code> directory. As before you can run
      the tests with the command <code>npm run test</code>.
    </p>
  </section>

  <section>
    <h3 class="left-border">Hints</h3>
    Now that you are writing code that updates the MongoDB database, bugs in your code can corrupt
    the database contents. Rerunning the <code>loadDatabase.js</code> program will reset your
    database to a clean state.  The tests assume you have done this before each run.
    <h4>Problem 1</h4>
    <p>
    This problem requires you to get the notion of a logged in user in both the React application
    and in the web server. You will need to get your pattern down for generating POST requests from your
    app to the web server and setup up the session state. The server-side
    functionality has tests you can run against it.
    </p>
    <p>
    Assuming you got your LoginRegister component written, added to your photo app, and routed
    to using the path "/login-register", we need to make that view be the one displayed if
    the user is not logged in.
    React Router provides a useful way of handeling redirects: <a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/Redirect.md">React Router Redirect</a>.
    You can modify your Route so that if the user is not logged in,
    it redirects to  /login-register.  For example, if you have a Route like:
    <div class="code">
<pre>
&lt;Route path="/users/:id" component={UserDetail} /&gt;
</pre>
     </div>
     and a component property this.userIsLoggedIn,
     you can have it go to /login-register by wrapping it in a conditional like:
     <div class="code">
 <pre>
{
    this.userIsLoggedIn ?
      &lt;Route path="/users/:id" component={UserDetail} /&gt;
    :
      &lt;Redirect path="/users/:id" to="/login-register" /&gt;
}
 </pre>
      </div>
        </p>
    <p>
    Since Problem 4 enhances the code you write for Problem 1 you might want to understand its needs
    before building your Problem 1 solution.
    </p>
    <h4>Problem 2</h4>
    <p>
    This problem will reuse most of what you needed to figure out for Problem 1.  One difference
    is comments are not standalone objects in our schema. They are embedded inside the photo object
      so you are required to perform an object update rather than an object creation.
    </p>
    <h4>Problem 3</h4>
    <p>
    Uploading files is hard in JavaScript frameworks since the browsers don't want JavaScript code to be
    able to read arbitrary files. Browsers do provide an interface to allow the user to select a file
    and then submit its contents to a web server. We can leverage that mechanism to allow our photo
    app to upload photos.
    </p>
    <p>
    React supports using HTML's <a
    <a href="https://reactjs.org/docs/uncontrolled-components.html#the-file-input-tag">
      input with type="file"
    </a>
    to have the user select files.
    The following line added to your photo app
    <div class="code">
<pre>&lt;input type="file" accept="image/*" ref={(domFileRef) => { this.uploadInput = domFileRef; }} />
</pre>
    </div>
    will get the browser to add an ugly button labelled "Choose File" that the user can push to select
    a local file. When the user selects a file this.uploadInput will contain the
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileList">
        DOM FileList
    </a>
    from the input element from which the
    DOM File
    can be taken and sent to the web server.

    You will need to also have a button that the user presses to actually submit the photo file to the server
    as decribed below.
    </p>
    <p>
    Once we have the selected file in the DOM we can add it to a
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData">
       DOM form
    </a>
    and send it in a POST
    request to the web server.  The following code provides an example of doing this.
    It assumes that the DOM fileList from the input element was put in this.uploadInput.
    <div class="code">
<pre>
    //this function is called when user presses the update button
    handleUploadButtonClicked = (e) => {
       e.preventDefault();
       if (this.uploadInput.files.length > 0) {

        // Create a DOM form and add the file to it under the name uploadedphoto
        const domForm = new FormData();
        domForm.append('uploadedphoto', this.uploadInput.files[0]);
        axios.post('/photos/new', domForm)
          .then((res) => {
            console.log(res);
          })
          .catch(err => console.log(`POST ERR: ${err}`));
    }
  }
</pre>
    </div>
    </p>
    <p>
    Express using body-parser can not handle a POST request with form containing a file but can with a
    middleware named <a href="https://www.npmjs.com/package/multer#readme"><code>multer</code></a>.
    Insert the following line after the require of multer:
    <div class="code"><pre>const processFormBody = multer({storage: multer.memoryStorage()}).single('uploadedphoto');</pre></div>
    <code>processFormBody</code> is a function we can use in our post request handler for
    <code>/photos/new</code>. <code>processFormBody</code> will look at the form
    for a field named "uploadedphoto" and pull the file out of it and place the information
    is a property named <code>file</code> on the request object. The following code gives you
    an idea of how to call it in your post request handler:
    <div class="code">
<pre>processFormBody(request, response, function (err) {
    if (err || !request.file) {
        // XXX -  Insert error handling code here.
        return;
    }
    // request.file has the following properties of interest
    //      fieldname      - Should be 'uploadedphoto' since that is what we sent
    //      originalname:  - The name of the file the user uploaded
    //      mimetype:      - The mimetype of the image (e.g. 'image/jpeg',  'image/png')
    //      buffer:        - A node Buffer containing the contents of the file
    //      size:          - The size of the file in bytes

    // XXX - Do some validation here.
    // We need to create the file in the directory "images" under an unique name. We make
    // the original file name unique by adding a unique prefix with a timestamp.
    const timestamp = new Date().valueOf();
    const filename = 'U' +  String(timestamp) + request.file.originalname;

    fs.writeFile("./images/" + filename, request.file.buffer, function (err) {
      // XXX - Once you have the file written into your images directory under the name
      // filename you can create the Photo object in the database
    });
});</pre>
    </div>
    </p>
    <p>
    The above code fragment uses the Node.js package
    <a href="https://nodejs.org/api/fs.html"><code>fs</code></a> so you will need to bring it
    into your webServer.js with:
    <div class="code"><pre>const fs = require("fs");</pre></div>
    </p>
    <h4>Problem 4</h4>
    <p>
    This problem combines the techniques you needed for the previous problems.
    </p>
  </section>

  <section>

    <h3 class="left-border">Deliverables</h3>
    <p>
    Use the standard class <a href="submit.html">submission mechanism</a>
    to submit the entire application (everything in the <code>project7</code>
    directory).   Please clean up your project directory before
    submitting, as described in the submission instructions. In addition delete
      any images you uploaded into your images directory.  If you kept the same
      naming convention for uploaded images that we had in the hints section you can
      delete them running the command:
      <code>rm -f images/U*</code> from your project7 directory.
    </p>

  </section>

</div>
</main>

    

    <footer>
  <div class="container text-center">
    <small class="text-muted">
    	Designed by Raymond Luong for CS142 at Stanford University
    	<br>
    	Powered by <a href="http://getbootstrap.com/" target="_blank">Bootstrap</a> and <a href="https://jekyllrb.com" target="_blank">Jekyll</a> â€“ <a href="website.html"><strong>learn more</strong></a>
    </small>
  </div>
</footer>


  </body>

</html>
